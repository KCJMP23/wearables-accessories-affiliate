# Cursor Rules for Affiliate Template Project

## Core Development Principles

### Production-Ready Code Only
- **NO shortcuts, mocks, TODOs, or "simplified" implementations**
- **NO "for now", "FIXME", "mock", or any shortcuts**
- All code must be production-ready and fully functional
- Review existing codebase before implementing new features
- DO NOT create new apps - implement user stories to existing 6 apps
- Gradually re-add any features that were simplified or removed

### File Size Limits
- **Maximum 500 lines per file**
- Extract into smaller files if necessary
- Use pnpm for package management

### Code Quality Standards
- Production-ready implementations only
- Full error handling and validation
- Comprehensive TypeScript types
- Proper testing coverage
- Responsive design for all screen sizes
- Accessibility compliance (WCAG 2.1 AA)

## Development Workflow

### Pre-Implementation Checklist
1. **Always call context7 MCP server first** for latest docs/tools
2. Read changelog.md, PRD, relevant user stories, and architecture docs
3. Update documentation as tasks are completed
4. Use ripgrep to prevent code duplication
5. Search GitHub for implementation examples

### MCP Tool Usage
Leverage all available MCPs:
- brave-search: For current events, post-Jan 2025 info, real-time data
- browser-tools: For testing and verification
- context7: For latest documentation and tools
- fetcher: For data fetching operations
- firebase: For Firebase integrations
- firecrawl: For web crawling tasks
- gcp: For Google Cloud Platform services
- lsmcp: For language model operations
- mem0 (memory): For persistent memory
- postgres: For database operations
- puppeteer: For browser automation and testing
- redis: For caching and session management
- sequential-thinking: For chess grandmaster approach
- tree-sitter: For code parsing and analysis
- xcf: For XcodeGen CLI operations

### Execution Strategy
- **Sequential thinking MCP**: Chess grandmaster approach
  - Write line → pause → test snippet → analyze → choose best path
- **Simultaneous tool invocation**: Use multiple independent tools simultaneously for maximum efficiency
- **Component reuse**: Maintain codebase consistency
- **Build verification**: Use puppeteer/browser-tools to verify builds actually work

## Problem Resolution

### Code Preservation
- Fix/preserve existing code rather than removing
- Implement unused imports rather than removing them
- After 3 failed attempts, use web search for solutions

### Web Search Triggers
Use web search for:
- Current events
- Post-January 2025 information
- Real-time data requirements
- When user asks about factual information requiring real-time data

## Project-Specific Requirements

### Architecture Compliance
- Follow the monorepo structure with Turborepo
- Implement Supabase with Row Level Security (RLS)
- Use Next.js 14.2.x with TypeScript 5.4.x
- Implement tRPC for type-safe API communication
- Use Prisma 5.x for database operations
- Implement Tailwind CSS 3.4.x with Shadcn/UI (NEVER use Tailwind v4)
- Use Zustand 4.x for state management

### CSS/Tailwind Requirements (CRITICAL)
- **MUST use Tailwind CSS v3.4.1** - Do NOT use v4
- **PostCSS config MUST use v3 syntax**: `tailwindcss: {}` not `"@tailwindcss/postcss": {}`
- **Check ALL package.json files** for consistent Tailwind versions
- **Use proper @tailwind directives**: `@tailwind base/components/utilities`
- **Clean build cache** when CSS issues occur: `rm -rf .next node_modules`
- **Never mix v3 and v4 syntax** - causes compilation errors

### User Stories Implementation
Focus on implementing these user stories from the PRD:
1. **Story 1.1**: Project Scaffolding (Turborepo monorepo)
2. **Story 1.2**: Supabase Project Setup (Database tables with RLS)
3. **Story 1.3**: Admin Authentication (Secure login with Supabase Auth)
4. **Story 2.1**: AI Service Integration (OpenAI/Claude + Leonardo.AI)
5. **Story 2.2**: Payload CMS Setup (Content management)
6. **Story 2.3**: Content Generation Workflow (AI-powered blog posts)
7. **Story 2.4**: Content Approval Workflow (Draft review system)

### Performance Requirements
- Google PageSpeed score of 90+
- Responsive design for all screen sizes
- Fast loading times
- SEO optimization

### Security Requirements
- Secure API key storage (Supabase Vault or environment variables)
- Row Level Security (RLS) on all site-specific data
- FTC compliance for affiliate links
- Amazon ToS compliance

## Quality Assurance

### Testing Strategy
- Unit tests for business logic
- Integration tests for API connections
- E2E tests for critical user flows
- Use Jest & RTL for frontend testing
- Use Playwright for E2E testing

### Code Review Standards
- All code must be production-ready
- No placeholder implementations
- Comprehensive error handling
- Full TypeScript coverage
- Responsive design verification
- Accessibility compliance

## Documentation Updates

### Required Updates
- Update changelog.md with each completed feature
- Update PRD with completed user stories
- Update architecture docs with implemented patterns
- Maintain up-to-date technical documentation

### Documentation Standards
- Clear, comprehensive documentation
- Code examples for complex implementations
- Architecture diagrams where needed
- API documentation for all endpoints

## Deployment Requirements

### Vercel Deployment
- Seamless Vercel integration
- CI/CD pipeline with GitHub Actions
- Turborepo remote caching for optimized builds
- Environment variable management

### Supabase Integration
- Production-ready Supabase instance
- Database migrations with Prisma
- Authentication with Supabase Auth
- Storage for images and files

## Final Notes

- **Zero tolerance for shortcuts or temporary solutions**
- **All implementations must be production-ready**
- **Maintain code quality and consistency**
- **Follow the established architecture patterns**
- **Ensure responsive design and accessibility**
- **Verify all builds work using browser automation**